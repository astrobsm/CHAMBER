/// <reference lib="webworker" />

import { clientsClaim } from 'workbox-core';
import {
  precacheAndRoute,
  cleanupOutdatedCaches,
  createHandlerBoundToURL,
} from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import {
  NetworkFirst,
  CacheFirst,
  StaleWhileRevalidate,
  NetworkOnly,
} from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { BackgroundSyncPlugin } from 'workbox-background-sync';

declare let self: ServiceWorkerGlobalScope;

// ============================================================================
// CORE SETUP
// ============================================================================

// Take control immediately
clientsClaim();

// Clean up old caches from previous versions
cleanupOutdatedCaches();

// Precache all assets generated by build
precacheAndRoute(self.__WB_MANIFEST);

// ============================================================================
// CACHE NAMES
// ============================================================================

const CACHE_NAMES = {
  pages: 'pages-cache-v2',
  api: 'api-cache-v2',
  apiMutations: 'api-mutations-v2',
  images: 'images-cache-v2',
  static: 'static-cache-v2',
  fonts: 'fonts-cache-v2',
  offline: 'offline-cache-v2',
};

// ============================================================================
// BACKGROUND SYNC — Queue failed mutations for retry
// ============================================================================

const bgSyncPlugin = new BackgroundSyncPlugin('offlineMutationQueue', {
  maxRetentionTime: 7 * 24 * 60, // Keep requests for 7 days
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        const response = await fetch(entry.request.clone());
        if (!response.ok) {
          throw new Error(`Server returned ${response.status}`);
        }
        console.log('[SW] Background sync success:', entry.request.url);

        // Notify clients about successful sync
        const clients = await self.clients.matchAll();
        clients.forEach((client) => {
          client.postMessage({
            type: 'BACKGROUND_SYNC_COMPLETE',
            url: entry!.request.url,
            timestamp: new Date().toISOString(),
          });
        });
      } catch (error) {
        console.error('[SW] Background sync failed, re-queuing:', entry.request.url);
        await queue.unshiftRequest(entry);
        throw error; // WorkboxBackgroundSync will retry
      }
    }
  },
});

// ============================================================================
// API ROUTES — GET requests (NetworkFirst with offline cache fallback)
// ============================================================================

// API GET requests — NetworkFirst strategy
// Returns cached data when offline, fresh data when online
const apiCacheStrategy = new NetworkFirst({
  cacheName: CACHE_NAMES.api,
  plugins: [
    new CacheableResponsePlugin({ statuses: [0, 200] }),
    new ExpirationPlugin({
      maxEntries: 200,
      maxAgeSeconds: 24 * 60 * 60, // 24 hours
      purgeOnQuotaError: true,
    }),
  ],
  networkTimeoutSeconds: 10, // Fall back to cache after 10s
});

// Cache all API GET requests
registerRoute(
  ({ url, request }) =>
    url.pathname.startsWith('/api/') && request.method === 'GET',
  apiCacheStrategy
);

// ============================================================================
// API MUTATIONS — POST/PUT/DELETE with Background Sync
// ============================================================================

// Sync-related mutations — NetworkOnly with BackgroundSync
// These queue up for retry when offline
const syncMutationStrategy = new NetworkOnly({
  plugins: [bgSyncPlugin],
});

// Sync endpoints — use background sync
registerRoute(
  ({ url, request }) =>
    url.pathname.startsWith('/api/sync/') &&
    ['POST', 'PUT'].includes(request.method),
  syncMutationStrategy,
  'POST'
);

registerRoute(
  ({ url, request }) =>
    url.pathname.startsWith('/api/sync/') &&
    ['POST', 'PUT'].includes(request.method),
  syncMutationStrategy,
  'PUT'
);

// Attendance check-in — background sync
registerRoute(
  ({ url, request }) =>
    url.pathname.includes('/attendance/check-in') && request.method === 'POST',
  new NetworkOnly({ plugins: [bgSyncPlugin] }),
  'POST'
);

// Test answer submissions — background sync (critical data)
registerRoute(
  ({ url, request }) =>
    url.pathname.includes('/tests/') &&
    url.pathname.includes('/answer') &&
    request.method === 'POST',
  new NetworkOnly({ plugins: [bgSyncPlugin] }),
  'POST'
);

// Other API mutations — NetworkFirst (non-critical)
const apiMutationStrategy = new NetworkFirst({
  cacheName: CACHE_NAMES.apiMutations,
  plugins: [
    new CacheableResponsePlugin({ statuses: [0, 200] }),
    new ExpirationPlugin({
      maxEntries: 50,
      maxAgeSeconds: 12 * 60 * 60,
    }),
    bgSyncPlugin,
  ],
});

for (const method of ['POST', 'PUT', 'DELETE', 'PATCH'] as const) {
  registerRoute(
    ({ url, request }) =>
      url.pathname.startsWith('/api/') &&
      !url.pathname.startsWith('/api/sync/') &&
      !url.pathname.includes('/check-in') &&
      !url.pathname.includes('/answer') &&
      request.method === method,
    apiMutationStrategy,
    method
  );
}

// ============================================================================
// STATIC ASSETS
// ============================================================================

// JavaScript & CSS — StaleWhileRevalidate
registerRoute(
  ({ request }) =>
    request.destination === 'script' || request.destination === 'style',
  new StaleWhileRevalidate({
    cacheName: CACHE_NAMES.static,
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// Fonts — CacheFirst (fonts rarely change)
registerRoute(
  ({ request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: CACHE_NAMES.fonts,
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year
      }),
    ],
  })
);

// Images — CacheFirst
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: CACHE_NAMES.images,
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// ============================================================================
// NAVIGATION — App Shell
// ============================================================================

const handler = createHandlerBoundToURL('/index.html');
const navigationRoute = new NavigationRoute(handler, {
  denylist: [
    /^\/_/,
    /\/api\//,
    /\.(?:png|jpg|jpeg|svg|gif|ico|woff2?)$/,
  ],
});
registerRoute(navigationRoute);

// ============================================================================
// OFFLINE FALLBACK
// ============================================================================

// Pre-cache the offline page
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAMES.offline).then((cache) =>
      cache.addAll([
        '/offline.html',
        '/manifest.json',
      ])
    )
  );
});

// ============================================================================
// MESSAGE HANDLING — Communication with main thread
// ============================================================================

self.addEventListener('message', (event) => {
  const { type, payload } = event.data || {};

  switch (type) {
    case 'SKIP_WAITING':
      self.skipWaiting();
      break;

    case 'CACHE_ROUTES':
      if (Array.isArray(payload)) {
        caches.open(CACHE_NAMES.pages).then((cache) => {
          payload.forEach((route: string) => {
            cache.add(route).catch(() => {
              // Silently ignore cache failures
            });
          });
        });
      }
      break;

    case 'CACHE_API_DATA':
      // Cache specific API response data from main thread
      if (payload?.url && payload?.data) {
        caches.open(CACHE_NAMES.api).then((cache) => {
          const response = new Response(JSON.stringify(payload.data), {
            headers: { 'Content-Type': 'application/json' },
          });
          cache.put(new Request(payload.url), response);
        });
      }
      break;

    case 'CLEAR_CACHE':
      caches.keys().then((cacheNames) => {
        cacheNames.forEach((cacheName) => {
          caches.delete(cacheName);
        });
      });
      break;

    case 'CLEAR_API_CACHE':
      caches.delete(CACHE_NAMES.api);
      caches.delete(CACHE_NAMES.apiMutations);
      break;

    case 'GET_CACHE_STATUS':
      getCacheStatus().then((status) => {
        event.source?.postMessage({
          type: 'CACHE_STATUS',
          payload: status,
        });
      });
      break;
  }
});

async function getCacheStatus() {
  const cacheKeys = await caches.keys();
  const status: Record<string, number> = {};

  for (const key of cacheKeys) {
    const cache = await caches.open(key);
    const keys = await cache.keys();
    status[key] = keys.length;
  }

  return status;
}

// ============================================================================
// PUSH NOTIFICATIONS
// ============================================================================

self.addEventListener('push', (event) => {
  if (!event.data) return;

  let data: { title?: string; body?: string; url?: string; actions?: NotificationAction[] };
  try {
    data = event.data.json();
  } catch {
    data = { body: event.data.text() };
  }

  const options: NotificationOptions = {
    body: data.body || '',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/badge-72x72.png',
    vibrate: [100, 50, 100],
    data: { url: data.url || '/' },
    actions: data.actions || [],
    tag: 'clinical-rotation',
    renotify: true,
  };

  event.waitUntil(
    self.registration.showNotification(
      data.title || 'Clinical Rotation Platform',
      options
    )
  );
});

self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  const url = event.notification.data?.url || '/';

  event.waitUntil(
    self.clients
      .matchAll({ type: 'window', includeUncontrolled: true })
      .then((clientList) => {
        for (const client of clientList) {
          if (client.url.includes(url) && 'focus' in client) {
            return client.focus();
          }
        }
        if (self.clients.openWindow) {
          return self.clients.openWindow(url);
        }
      })
  );
});

// ============================================================================
// PERIODIC BACKGROUND SYNC
// ============================================================================

self.addEventListener('periodicsync', ((event: any) => {
  if (event.tag === 'sync-clinical-data') {
    event.waitUntil(triggerClientSync());
  }
}) as EventListener);

async function triggerClientSync(): Promise<void> {
  const clients = await self.clients.matchAll({ type: 'window' });
  clients.forEach((client) => {
    client.postMessage({
      type: 'SYNC_TRIGGERED',
      timestamp: new Date().toISOString(),
    });
  });
}

// ============================================================================
// FETCH — Offline fallback for navigations
// ============================================================================

self.addEventListener('fetch', (event) => {
  // Only handle navigation requests that aren't caught by other strategies
  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request).catch(() => {
        return caches.match('/offline.html').then((response) => {
          return response || new Response('Offline', {
            status: 503,
            statusText: 'Service Unavailable',
          });
        });
      })
    );
  }
});

console.log('[SW] Clinical Rotation Platform Service Worker loaded — v2');
